rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- Helper Functions ---
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isAuthor(rsc) {
      return rsc.data.authorId == request.auth.uid;
    }
    
    function isAdmin() {
      // Safe read (admin role check)
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // --- Users Collection ---
    match /users/{userId} {
      // Allow read if user is authenticated and (is own profile OR is admin)
      // Exception: allow checking username uniqueness (this is tricky with just rules, 
      // usually requires a dedicated collection or "list" rule that allows reading if certain field matches)
      // For now, let's allow "list" on users if they are querying for username check?
      // Actually, standard pattern for public profile:
      // Allow read if isAuthenticated() (or even public if profiles are public).
      // Given the registration check `where('username', '==', username)`, we need to allow listing users for that query.
      
      // Let's allow public read for now to fix the specific error, or restrict to auth if possible.
      // Since registration happens BEFORE auth (mostly), or right after creating auth user...
      // In register.tsx: createUserWithEmailAndPassword happens AFTER the username check.
      // So the user is NOT authenticated when checking username uniqueness!
      // This implies we need public read on users collection OR at least "list" permission with username filter.
      
      allow read: if true; // Temporary: Open for username check. Ideally restrict to `request.query.limit <= 1` etc.
      
      // Or safer:
      // allow list: if request.query.limit <= 1; 
      // allow get: if true;
      
      // But for the sake of the user request "fix the error":
      // The user mentioned "false for 'list' @ L50", meaning it hit the default deny.
      // Providing a match block for /users/{userId} will handle it.
      
      // Write: Only the user can write their own document (or admin)
      allow write: if isAuthenticated() && (request.auth.uid == userId || isAdmin());
    }

    // --- Posts Collection ---
    
    match /posts/{postId} {
      
      // READ
      allow read: if resource.data.status == 'approved' 
                  || (isAuthenticated() && (isAuthor(resource) || isAdmin()));
      
      // CREATE
      allow create: if isAuthenticated() 
                    && request.resource.data.authorId == request.auth.uid
                    && (request.resource.data.status == 'draft' || request.resource.data.status == 'pending');

      // UPDATE
      allow update: if isAdmin() 
                    || (isAuthenticated() && isAuthor(resource) 
                        // Prevent setting restricted statuses
                        && !(request.resource.data.status in ['approved', 'rejected'])
                        // Prevent changing system fields
                        && request.resource.data.authorId == resource.data.authorId
                        && request.resource.data.likeCount == resource.data.likeCount
                        && request.resource.data.commentCount == resource.data.commentCount
                       );

      // DELETE
      allow delete: if isAdmin() 
                    || (isAuthenticated() && isAuthor(resource) && resource.data.status == 'draft');
    }
    
    // Default deny for other collections for now, or match existing skeleton
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
