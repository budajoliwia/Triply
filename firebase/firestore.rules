rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- Helper Functions ---
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isAuthor(rsc) {
      return rsc.data.authorId == request.auth.uid;
    }

    function isPostAuthorById(postId) {
      return isAuthenticated()
        && get(/databases/$(database)/documents/posts/$(postId)).data.authorId == request.auth.uid;
    }

    // Same visibility as a post document:
    // - approved: any authenticated user can read
    // - pending/draft/rejected: only post author or admin
    function canReadPostById(postId) {
      return exists(/databases/$(database)/documents/posts/$(postId))
        && (
          get(/databases/$(database)/documents/posts/$(postId)).data.status == 'approved'
          || (
            isAuthenticated()
            && (get(/databases/$(database)/documents/posts/$(postId)).data.authorId == request.auth.uid || isAdmin())
          )
        );
    }
    
    function isAdmin() {
      // Safe read (admin role check)
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function userCountersUnchanged() {
      // Block any client-side updates to counters.
      // For older docs, treat missing counters as 0.
      let currentFollowers = resource.data.get('followersCount', 0);
      let currentFollowing = resource.data.get('followingCount', 0);
      let nextFollowers = request.resource.data.get('followersCount', currentFollowers);
      let nextFollowing = request.resource.data.get('followingCount', currentFollowing);
      return nextFollowers == currentFollowers && nextFollowing == currentFollowing;
    }

    function isValidBio() {
      return !('bio' in request.resource.data)
        || request.resource.data.bio == null
        || (request.resource.data.bio is string && request.resource.data.bio.size() <= 160);
    }

    function isValidAvatarPath(userId) {
      return !('avatarPath' in request.resource.data)
        || request.resource.data.avatarPath == null
        || (request.resource.data.avatarPath is string
            && request.resource.data.avatarPath == ('avatars/' + userId + '.jpg'));
    }

    function isValidUserCreate(userId) {
      // Prevent self-admin and enforce safe defaults at registration time.
      return request.resource.data.keys().hasOnly([
          'email',
          'username',
          'usernameLower',
          'role',
          'dailyPostLimit',
          'usedToday',
          'lastUsageDate',
          'followersCount',
          'followingCount',
          'createdAt',
          // Optional profile fields
          'bio',
          'avatarPath'
        ])
        && request.resource.data.role == 'user'
        && request.resource.data.dailyPostLimit == 5
        && request.resource.data.usedToday == 0
        && request.resource.data.followersCount == 0
        && request.resource.data.followingCount == 0
        && request.resource.data.createdAt is timestamp
        && request.resource.data.email is string
        && request.resource.data.email.size() <= 254
        && request.resource.data.username is string
        && request.resource.data.username.size() >= 3
        && request.resource.data.username.size() <= 30
        && request.resource.data.usernameLower is string
        && request.resource.data.usernameLower.size() >= 3
        && request.resource.data.usernameLower.size() <= 30
        && request.resource.data.lastUsageDate is string
        && request.resource.data.lastUsageDate.matches('^\\d{4}-\\d{2}-\\d{2}$')
        && isValidBio()
        && isValidAvatarPath(userId);
    }

    function onlyProfileFieldsChanged() {
      // Allow editing ONLY user-facing profile fields from the client.
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['bio', 'avatarPath']);
    }
    
    // --- Users Collection ---
    match /users/{userId} {
      allow read: if true; 
      // Create user doc (registration)
      allow create: if isAuthenticated()
                    && request.auth.uid == userId
                    && isValidUserCreate(userId);
      // Production hardening:
      // - ONLY the owner may update their own profile fields (bio/avatarPath)
      // - clients cannot modify role, limits, counters, etc. (Cloud Functions bypass rules)
      allow update: if isAuthenticated()
                    && request.auth.uid == userId
                    && userCountersUnchanged()
                    && onlyProfileFieldsChanged()
                    && isValidBio()
                    && isValidAvatarPath(userId);
      allow delete: if false;

      // --- Following Subcollection ---
      // users/{userId}/following/{targetUid}
      match /following/{targetUid} {
        // Anyone can read who someone follows? Let's say yes for now, or just authenticated.
        allow read: if isAuthenticated();
        // Only the user themselves can add/remove people they follow
        allow create, delete: if isAuthenticated() && request.auth.uid == userId;
        allow update: if false;
      }

      // --- Followers Subcollection ---
      // users/{userId}/followers/{followerUid}
      match /followers/{followerUid} {
        allow read: if isAuthenticated();
        // Only allow the follower to create/delete their own follower edge.
        // Path: users/{targetUid}/followers/{request.auth.uid}
        allow create, delete: if isAuthenticated() && request.auth.uid == followerUid;
        allow update: if false;
      }
    }

    // --- Posts Collection ---
    
    match /posts/{postId} {
      
      // READ
      allow read: if resource.data.status == 'approved' 
                  || (isAuthenticated() && (isAuthor(resource) || isAdmin()));
      
      // CREATE
      allow create: if isAuthenticated() 
                    && request.resource.data.authorId == request.auth.uid
                    && (request.resource.data.status == 'draft' || request.resource.data.status == 'pending');

      // UPDATE
      allow update: if isAdmin() 
                    || (
                      isAuthenticated()
                      && (
                        (
                          // Author updates (same as before, counters immutable here)
                          isAuthor(resource) 
                          // Prevent client from editing approved/rejected posts or setting restricted statuses
                          && (resource.data.status in ['draft', 'pending'])
                          && (request.resource.data.status in ['draft', 'pending'])
                          // Prevent changing system fields
                          && request.resource.data.authorId == resource.data.authorId
                          // CRITICAL: Prevent client from changing counters directly
                          && request.resource.data.likeCount == resource.data.likeCount
                          && request.resource.data.commentCount == resource.data.commentCount
                          // Prevent changing creation time
                          && request.resource.data.createdAt == resource.data.createdAt
                        )
                      )
                    );

      // DELETE
      allow delete: if isAdmin() 
                    || (isAuthenticated() && isAuthor(resource) && resource.data.status == 'draft');

      // --- Likes Subcollection ---
      // posts/{postId}/likes/{userId}
      match /likes/{userId} {
        allow read: if isAuthenticated() && canReadPostById(postId);
        // Create: Only allow if document ID matches authenticated User ID
        allow create: if isAuthenticated()
                      && canReadPostById(postId)
                      && request.auth.uid == userId
                      && request.resource.data.keys().hasOnly(['createdAt'])
                      && request.resource.data.createdAt is timestamp;
        // Delete: Only allow if document ID matches authenticated User ID
        allow delete: if isAuthenticated() && canReadPostById(postId) && request.auth.uid == userId;
        allow update: if false;
      }

      // --- Comments Subcollection ---
      // posts/{postId}/comments/{commentId}
      match /comments/{commentId} {
        allow read: if isAuthenticated() && canReadPostById(postId);
        // Create: Allow any authenticated user to comment
        allow create: if isAuthenticated()
                      && canReadPostById(postId)
                      && request.resource.data.keys().hasOnly(['authorId', 'text', 'createdAt'])
                      && request.resource.data.authorId == request.auth.uid
                      && request.resource.data.text is string
                      && request.resource.data.text.size() > 0
                      && request.resource.data.text.size() <= 500
                      && request.resource.data.createdAt is timestamp;
        // Delete: Allow author or admin to delete
        allow delete: if isAuthenticated()
                      && canReadPostById(postId)
                      && (resource.data.authorId == request.auth.uid || isAdmin());
        allow update: if false;
      }

      // --- Post Events Subcollection (audit log) ---
      // posts/{postId}/postEvents/{eventId}
      match /postEvents/{eventId} {
        // Mirror post visibility: admin or post author.
        allow read: if isAuthenticated() && (isAdmin() || isPostAuthorById(postId));

        // Clients may ONLY create clean moderation events (Cloud Functions bypass rules).
        allow create: if isAuthenticated()
                      && isAdmin()
                      && request.resource.data.keys().hasOnly(['type', 'actorId', 'createdAt'])
                      && request.resource.data.actorId == request.auth.uid
                      && request.resource.data.type in ['approved', 'rejected']
                      && ('createdAt' in request.resource.data)
                      && request.resource.data.createdAt is timestamp;

        allow update, delete: if false;
      }
    }

    // --- Notifications Collection ---
    // notifications/{notificationId}
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.targetUserId;

      // Clients cannot create or delete notifications (backend only).
      allow create, delete: if false;

      // Optional: allow client to mark as read, without changing other fields.
      allow update: if isAuthenticated()
                    && request.auth.uid == resource.data.targetUserId
                    // only allow transitioning to read=true
                    && resource.data.read == false
                    && request.resource.data.read == true
                    // and only the 'read' field may change
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
    }

    // --- Notifications (per-user subcollection, new model) ---
    // notifications/{userId}/items/{notificationId}
    match /notifications/{userId}/items/{notificationId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Backend-only writes.
      allow create, delete: if false;

      // Allow client to mark as read, without changing other fields.
      allow update: if isAuthenticated()
                    && request.auth.uid == userId
                    && resource.data.read == false
                    && request.resource.data.read == true
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
    }

    // --- Admin Inbox Notifications ---
    // adminNotifications/{notificationId}
    match /adminNotifications/{notificationId} {
      allow read: if isAuthenticated() && isAdmin();

      // Backend-only writes.
      allow create, delete: if false;

      // Allow admin to mark as read only.
      allow update: if isAuthenticated()
                    && isAdmin()
                    && resource.data.read == false
                    && request.resource.data.read == true
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
    }
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
